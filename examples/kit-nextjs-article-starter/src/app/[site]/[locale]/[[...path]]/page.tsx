import { isDesignLibraryPreviewData } from '@sitecore-content-sdk/nextjs/editing';
import { notFound } from 'next/navigation';
import { draftMode, headers } from 'next/headers';
import { SiteInfo } from '@sitecore-content-sdk/nextjs';
import sites from '.sitecore/sites.json';
import { routing } from 'src/i18n/routing';
import scConfig from 'sitecore.config';
import client from 'src/lib/sitecore-client';
import Layout, { RouteFields } from 'src/Layout';
import components from '.sitecore/component-map';
import Providers from 'src/Providers';
import { NextIntlClientProvider } from 'next-intl';
import { setRequestLocale } from 'next-intl/server';
import { StructuredData } from '@/components/structured-data/StructuredData';
import { generateWebPageSchema } from '@/lib/structured-data/schema';

// Configure dynamic rendering to avoid SSR issues with client-side hooks
// This ensures all pages are rendered on-demand rather than pre-rendered at build time
export const dynamic = 'force-dynamic';

type PageProps = {
  params: Promise<{
    site: string;
    locale: string;
    path?: string[];
    [key: string]: string | string[] | undefined;
  }>;
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
};

export default async function Page({ params, searchParams }: PageProps) {
  const { site, locale, path } = await params;
  const draft = await draftMode();
  const headersList = await headers();
  const host = headersList.get('host') || '';
  const protocol = process.env.NODE_ENV === 'development' ? 'http' : 'https';
  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || (host ? `${protocol}://${host}` : '');

  // Set site and locale to be available in src/i18n/request.ts for fetching the dictionary
  setRequestLocale(`${site}_${locale}`);

  // Fetch the page data from Sitecore
  let page;
  if (draft.isEnabled) {
    const editingParams = await searchParams;
    if (isDesignLibraryPreviewData(editingParams)) {
      page = await client.getDesignLibraryData(editingParams);
    } else {
      page = await client.getPreview(editingParams);
    }
  } else {
    page = await client.getPage(path ?? [], { site, locale });
  }

  // If the page is not found, return a 404
  if (!page) {
    notFound();
  }

  // Fetch the component data from Sitecore (Likely will be deprecated)
  const componentProps = await client.getComponentData(
    page.layout,
    {},
    components,
  );

  const routeFields = page.layout.sitecore.route?.fields as RouteFields;
  const pageTitle = routeFields?.Title?.value?.toString() || 'Page';
  const pageDescription = routeFields?.ogDescription?.value?.toString();

  const pathSegments = path && path.length > 0 ? path.join('/') : '';
  const urlPath = `/${site}/${locale}${pathSegments ? `/${pathSegments}` : ''}`;
  const fullUrl = baseUrl ? `${baseUrl}${urlPath}` : undefined;

  const webPageSchema = generateWebPageSchema({
    name: pageTitle,
    description: pageDescription,
    url: fullUrl,
    inLanguage: locale.replace('_', '-'),
    ...(baseUrl && {
      isPartOf: {
        name: 'Solterra & Co.',
        url: baseUrl,
      },
    }),
  });

  return (
    <NextIntlClientProvider>
      <Providers page={page} componentProps={componentProps}>
        <StructuredData id="webpage-schema" data={webPageSchema} />
        <Layout page={page} />
      </Providers>
    </NextIntlClientProvider>
  );
}

// This function gets called at build and export time to determine
// pages for SSG ("paths", as tokenized array).
export const generateStaticParams = async () => {
  if (process.env.NODE_ENV !== 'development' && scConfig.generateStaticPaths) {
    // Filter sites to only include the sites this starter is designed to serve.
    // This prevents cross-site build errors when multiple starters share the same XM Cloud instance.
    const defaultSite = scConfig.defaultSite;
    const allowedSites = defaultSite
      ? sites
          .filter((site: SiteInfo) => site.name === defaultSite)
          .map((site: SiteInfo) => site.name)
      : sites.map((site: SiteInfo) => site.name);
    return await client.getAppRouterStaticParams(
      allowedSites,
      routing.locales.slice(),
    );
  }
  return [];
};

/**
 * Generates metadata for the page including Open Graph and Twitter Card tags.
 * These tags enable rich previews when shared on social platforms and help
 * generative AI engines understand page context for ranking and snippet generation.
 * @param {PageProps} params - Page parameters including path, site, and locale
 * @returns {Promise<Metadata>} Next.js metadata object with OG and Twitter card tags
 */
export const generateMetadata = async ({ params }: PageProps) => {
  const headersList = await headers();
  const host = headersList.get('host');
  const protocol = process.env.NODE_ENV === 'development' ? 'http' : 'https';
  const baseUrl = `${protocol}://${host}`;

  const { path, site, locale } = await params;

  // Construct the canonical URL using the public-facing path (what users see in browser)
  // The middleware rewrites / -> /site/locale internally, but canonical should match the browser URL
  const pathSegment = path?.length ? `/${path.join('/')}` : '';
  const canonicalUrl = `${baseUrl}${pathSegment}`;

  // The same call as for rendering the page. Should be cached by default react behavior
  const page = await client.getPage(path ?? [], { site, locale });

  // Cast route fields once to avoid repeated type assertions
  const routeFields = (page?.layout.sitecore.route?.fields ?? {}) as RouteFields;

  // Extract metadata values with fallback chain
  const metadataTitle =
    routeFields?.metadataTitle?.value?.toString() ||
    routeFields?.pageTitle?.value?.toString() ||
    routeFields?.Title?.value?.toString() ||
    'Page';

  const metadataDescription =
    routeFields?.metadataDescription?.value?.toString() ||
    routeFields?.pageSummary?.value?.toString() ||
    'Solterra & Co. - Editorial-style content for lifestyle brands';

  const ogTitle =
    routeFields?.ogTitle?.value?.toString() ||
    metadataTitle;

  const ogDescription =
    routeFields?.ogDescription?.value?.toString() ||
    metadataDescription;

  // Ensure image URL is absolute (HTTPS preferred)
  const imageSource =
    routeFields?.ogImage?.value?.src ||
    routeFields?.thumbnailImage?.value?.src;

  const ogImageUrl = imageSource
    ? imageSource.startsWith('http')
      ? imageSource
      : `${baseUrl}${imageSource.startsWith('/') ? '' : '/'}${imageSource}`
    : undefined;

  // Construct the full page URL
  const pagePath = path ? `/${path.join('/')}` : '';
  const pageUrl = `${baseUrl}${pagePath}`;

  return {
    title: metadataTitle,
    description: metadataDescription,
    openGraph: {
      title: ogTitle,
      description: ogDescription,
      url: pageUrl,
      type: 'website',
      siteName: site || 'Solterra & Co.',
      locale: locale || 'en',
      images: ogImageUrl
        ? [
            {
              url: ogImageUrl,
              width: 1200,
              height: 630,
              alt: ogTitle,
            },
          ]
        : undefined,
    },
    twitter: {
      card: 'summary_large_image',
      title: ogTitle,
      description: ogDescription,
      images: ogImageUrl ? [ogImageUrl] : undefined,
    },
  };
};
